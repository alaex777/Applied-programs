\documentclass[12pt]{article}

\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
%  - Размеры полей -
\usepackage[right=1.5cm,top=2cm,left=3cm,bottom=2cm]{geometry}
%  - Отступ в начале первого абзаца -
\usepackage{indentfirst}
%  - Титульный лист с содержанием -
\usepackage{course}
\usepackage{hyperref}

\linespread{1.5}

\newtheorem{thm}{Теорема}[section]
\newtheorem{defn}{Определение}[section]
\newtheorem{lem}{Лемма}[section]

\courseTitle{О нормальной форме простых программ над двоичными деревьями}
%  - Как вас зовут. В РОДИТЕЛЬНОМ ПАДЕЖЕ -
\courseAuthor{Балашова Александра Владимировича}
%  - Степень, должность и Фамилия И.О. научного руководителя -
\courseSupervisorTitle{к.ф.-м.н.,~доцент}
\courseSupervisorName{Подымов~В.\,В.}

\begin{document}

\coursePutTitleContents

\section{Введение}
В работе рассматривается задача проверки эквивалентности программ и решение этой задачи, основанное на составлении адекватного тестового покрытия.\hyperlink{bibl2}{[2]} Адекватным тестовым покрытием назовем конечное подмножество множества для которых и рассматриваются программы. Задача же заключается в проверке совпадения результатов работы программ на адекватном тестовом покрытии. Эта задача неразрешима для многих языков программ \hyperlink{bibl1}{[1]}, таких как Тьюринг-полные языки, язык примитивно рекурсивных функций и даже язык полиномов с целочисленными коэффициентами. В \hyperlink{bibl2}{[2]} предлагается рассмотреть класс простых программ для которых эта задача разрешима. В этих программах нет циклов, рекурсий, есть условный оператор и простейшие действия над деревьями. Программы называются простыми, потому что существует язык программ, где уже есть циклы.\hyperlink{bibl3}{[3]} Двоичные деревья - распространённая и простая структура данных, и при этом достаточно полезная: такие деревья можно использовать, например, для представления булевых значений, натуральных чисел и списков. В работе рассматривается класс простых программ на них. А так же рассмотрим задачу проверки эквивалентности таких программ. Цель данной работы состоит в исследовании и улучшении алгоритма проверки эквивалентности программ на двоичных деревьях, предлагающегося в \hyperlink{bibl2}{[2]}.
\pagebreak

\section{Основные понятия}

\subsection{Простые программы над двоичными деревьями}
Будем рассматривать двоичные деревья, у которых не может отсутствовать левое или правое поддерево. Синтаксис \emph{деревьев} \hyperlink{bibl2}{[2]} зададим формой Бэкуса-Науэра \\
\begin{defn} $T ::= nil \ | \ (T \ . \ T)$, где nil - пустое дерево, Т - двоичное дерево.\end{defn} \\
Рассматриваются непустые корневые упорядоченные двоичные деревья. nil - это дерево из одной вершины. $(T_{1}.T_{2})$ - это дерево, первым (левым) поддеревом которого является $T_{1}$, и вторым (правым) - $T_{2}$. Такие деревья могут быть полезны, так как с их помощью можно выразить булевы значения, натуральные числа и списки\hyperlink{bibl2}{[2]}:\\
\begin{itemize}
 \item $\lceil\bullet\rceil_{Bool} : Bool \rightarrow T$ -  отображение из множества булевых значений в множество деревьев T.\\
 		- $\lceil false\rceil_{Bool} = nil$ --- false отобравается в дерево из одной вершины.\\
 		- $\lceil true\rceil_{Bool} = (nil . nil)$ --- true отображается в дерево из трех вершин, высоты 1.\\
 \item $\lceil\bullet\rceil_{\mathbb{N} \cup \{0\}} : \mathbb{N} \cup \{0\}  \rightarrow T$ - отображение из множества натуральных чисел в множество деревьев T.\\
 		- $\lceil 0\rceil_{\mathbb{N} \cup \{0\}} = nil$ --- 0 отобравается в дерево из одной вершины.\\
 		- $\lceil n + 1\rceil_{\mathbb{N} \cup \{0\}} = (nil . \lceil n \rceil_{\mathbb{N}})$ --- любое число больше 0 отображается в дерево, у которого левое поддерево состоит из одной вершины, а правое - из дерева, соответствующего предыдущему числу. \\
 \item $\lceil\bullet\rceil_{List(X)} : List(X) \rightarrow T$ --- отображение из множества списков состоящих из элементов типа X, имеющего представление деревьями, в множество деревьев T.\\
 		- $\lceil []\rceil_{List(X)} = nil$ --- пустой список отобравается в дерево из одной вершины.\\
 		- $\lceil [x_{1}, x_{2}, ..., x_{n}]\rceil_{List(X)} = (\lceil x_{1} \rceil_{X} . \lceil [x_{2}, ..., x_{n}]\rceil_{List(X)})$ --- любой непустой список отображается в дерево, у которого левое поддерево состоит из дерева соответствующего первому элементу списка, а правое - из дерева соответствующего списку без первого элемента.
\end{itemize}\\
Введем понятие программы над описанными выше деревьями. Как и в случае с деревьями, сделаем это с помощью БНФ.\\
\begin{defn} \hyperlink{bibl2}{[2]} $E ::= I \ | \ hd \ | \ tl \ | \ nil \ | \ cons(E, E) \ | \ E \circ E \ | \ ifnil(E, E, E)$, где Е - программа над деревьями Т. Смысл операций I, hd, tl, nil, cons(), $\circ$, ifnil() описан ниже.\end{defn}\\
Опишем семантику программ: каждая программа в квадратных скобках обозначает отображение из T в T: $[\bullet]: T \rightarrow T$
\begin{enumerate}
	\item $[I](x) = x$ --- программа, возвращающая входное дерево без изменений.
	\item $[hd](t_{1}. t_{2}) = t_{1}$ --- программа, возвращающая левое поддерево.
	\item $[tl](t_{1}. t_{2}) = t_{2}$ --- программа, возвращающая правое поддерево.
	\item $[nil](x) = nil$ --- программа, для любого дерева возвращающая nil.
	\item $[cons(e_{1}, e_{2})](x) = ([e_{1}](x). [e_{2}](x))$ --- программа, возвращающая новое дерево, состоящее из поддеревьев, полученных путем применения $e_{1}$ и $e_{2}$ к дереву x.
	\item $[e_{1} \circ e_{2}](x) = [e_{1}]([e_{2}](x))$ --- программа, которая последовательно применяет к дереву сначала $e_{2}$, а потом к результату применяет $e_{1}$. Назовем ее последовательной композицией.
	\item $[ifnil(e_{1}, e_{2}, e_{3})](x) = [e_{2}](x)$, если $[e_{1}](x) = nil$.
	\item $[ifnil(e_{1}, e_{2}, e_{3})](x) = [e_{3}](x)$, если $[e_{1}](x) = (t_{1}. t_{2})$ --- ifnil возвращает результат применеия $e_{2}$ к входному дереву, если результат применения $e_{1}$ к исходному дереву возвращает nil, и возвращает результат применения $e_{3}$ к входному дереву в другом случае.
\end{enumerate}\\
Итого операциями программы считаются: I, hd, tl, nil, cons(), $\circ$ и ifnil(). Будем считать, что сложность каждой операции равна 1.\\
\begin{defn} $|p_{n}|$ - сложность программы $p_{n}$ - суммарная сложность всез операций программы $p_{n}$ \end{defn}\\

\subsection{Нормальная форма программ}
\begin{defn} \hyperlink{bibl2}{[2]} $E^{nf} ::= nil\ |\ cons(E^{nf}, E^{nf})\ |\ sel_{1} \circ ... \circ sel_{n}\ |\ ifnil(sel_{1} \circ ... \circ sel_{n}, E^{nf}, E^{nf}), \ sel_{i} \in \{hd, tl\}, i \in [1,n]$, где пустое множество композиций sel значит I \end{defn}\\
Опишем тождества приведения программ к нормальной форме\\
\begin{enumerate}
	\item[T_{1}:] $I \circ e = e \circ I = e$
	\item[T_{2}:] $sel \circ cons(e_{1}, e_{2}) = e_{i}$
	\item[T_{3}:] $nil \circ e = nil$
	\item[T_{4}:] $cons(e_{1}, e_{2}) \circ e_{3} = cons(e_{1} \circ e_{3}, e_{2} \circ e_{3})$
	\item[T_{5}:] $e \circ ifnil(e_{1}, e_{2}, e_{3}) = ifnil(e_{1}, e \circ e_{2}, e \circ e_{3})$
	\item[T_{6}:] $ifnil(e_{1}, e_{2}, e_{3}) \circ e = ifnil(e_{1} \circ e, e_{2} \circ e, e_{3} \circ e)$
	\item[T_{7}:] $ifnil(nil, e_{1}, e_{2}) = e_{1}$
	\item[T_{8}:] $ifnil(cons(e_{h}, e_{t}), e_{1}, e_{2}) = e_{2}$
	\item[T_{9}:] $ifnil(ifnil(e_{1}, e_{2}, e_{3}), e'_{1}, e'_{2}) = ifnil(e_{1}, ifnil(e_{2}, e'_{1}, e'_{2}), ifnil(e_{3}, e'_{2}, e'_{3}))$
\end{enumerate}\\

\subsection{Теорема об эквивалентности программ в нормальной форме}
Введем понятие глубины \emph{depth} \hyperlink{bibl2}{[2]} дерева. \\
\begin{defn} Глубиной дерева \emph{depth} будем называть такое отображение $depth : T \rightarrow \mathbb{N}\), что \(depth(nil) = 0\), \(depth(t_{1} . t_{2}) = 1 + max(depth(t_{1}), depth(t_{2}))$\\
Введем также понятие дерева глубины не более чем N.\end{defn} \\
\begin{defn} \hyperlink{bibl2}{[2]} $T_{N}$ = \{$t \in T$ | $depth(t) \leq N$\} \end{defn}\\
Так же нам потребуется определение программ в нормальной форме глубины N\\
\begin{defn} \hyperlink{bibl2}{[2]} $E^{nf}_{N}$ ::= $nil$ | $cons(E^{nf}_{N}, E^{nf}_{N})$ | $sel_{1} \circ ... \circ sel_{n}$ | $ifnil(sel_{1} \circ ... \circ sel_{n}, E^{nf}_{N}, E^{nf}_{N})$, $n \leq N$ \end{defn}\\
\begin{thm} \hyperlink{bibl2}{[2]} Для любого натурального n и двух любых программ из множества программ в нормальной форме, глубины не более чем N, если результат этих программ одинаков на всех деревьях глубины не более чем N+1, то результат таких программ будет одинаков на всех деревьях, то есть они равны в смысле тестирования.\end{thm} \\

\subsection{Схема проверки эквивалентности двух программ}
\begin{defn} \hyperlink{bibl2}{[2]} $nf: E \rightarrow E^{nf}$, отображение преобразующее программу в ее нормальную форму \end{defn}\\
Стоит отметить, что реализация алгоритма, преобразовывающего программу в нормальную форму, не была явно представлена автором статьи \hyperlink{bibl2}{[2]}. Этот алгоритм будет представлен в 4.1.\\
\begin{defn} Назовем \emph{нормальным параметром} программы \(e\) число $N \in \mathbb{N}: e^{nf}=nf(e) \in E^{nf}_{N}$, но $e^{nf}=nf(e) \notin E^{nf}_{N-1}$ \end{defn}
Приведем схему, позволяющую проверить, эквивалентны ли две программы \(e_{1}, e_{2}\) \hyperlink{bibl2}{[2]}\\
\begin{enumerate}
\item Найдем наименьшее N такое, что $nf(e_{1}), nf(e_{2}) \in E_{N}^{nf}$
\item Проверим что для всех $t \in T_{N+1}$ выполняется $[e_{1}](t) = [e_{2}](t)$
\end{enumerate}\\
В первом пункте автором \hyperlink{bibl2}{[2]} неявно предполагается, что поиск такого требуемого N заключается в построении нормальных форм программ $e_{1}$, $e_{2}$ и явном нахождении наибольшего числа подряд идущих операций композиций в этих формах. Сложность схемы будет зависеть от количества деревьев, глубины не более чем N+1, а их  количество равно $c^{2^{N+2}}$, где c = 1.2259... \hyperlink{bibl2}{[2]} Сложность схемы получилась суперэкспоненциальной, а соответственно неэффективной.\\
\pagebreak

\section{Постановка задачи}
\begin{enumerate}
\item Явно описать алгоритм приведения простой программы над двоичными деревьями, не вполне явно приведённый в \hyperlink{bibl2}{[2]}, и использующийся для проверки эквивалентности программ так, как это рассказано в разделе 2.4,  и оценить сложность нормальной формы, получающейся по этому алгоритму, относительно числа операций исходной программы в худшем случае.
\item Предложить алгоритм нахождения нормального параметра программы е, более эффективный по сравнению с упомянутым в разделе 2.4.
\item Оценить нормальный параметр программы для уточнения оценки сложности алгоритма, изложенного в разделе 2.4.
\end{enumerate}
\pagebreak

\section{Основная часть}

\subsection{Алгоритм преобразования программы к нормальной форме}
\textbf{Алгоритм} A: A($p$) = $p_{nf}$, $p$ - программа на двоичных деревьях, $p_{nf}$ - эквивалентная программа в нормальной форме\\
A:
\begin{enumerate}
	\item Пока в программе p есть тождества вида $T_{1}-T_{6}$ применяется любое из применимых преобразований
	\begin{itemize}
		\item Пока в программе p есть выражения вида $I \circ e$, $e \circ I$ выполняем преобразование $T_{1}$
		\item Пока в программе p есть выражения вида $tl \circ cons(e_{1}, e_{2})$, $hd \circ cons(e_{1}, e_{2})$ выполняем преобразование $T_{2}$
		\item Если в программе p есть выражения вида $nil \circ e$ выполняем преобразование $T_{3}$
		\item Если в программе p есть выражения вида $cons(e_{1}, e_{2}) \circ  e_{3}$ выполняем преобразование $T_{4}$
		\item Если в программе p есть выражения вида $e \circ ifnil(e_{1}, e_{2}, e_{3})$ выполняем преобразование $T_{5}$
		\item Если в программе p есть выражения вида $ifnil(e_{1}, e_{2}, e_{3}) \circ e$ выполняем преобразование $T_{6}$
	\end{itemize}
	Итогом работы этой части алгоритма будет программа $p_{1}$
	\item Пока в программе \(p_{1}\) есть тождества вида $T_{7}-T_{9}$ применяется любое из применимых преобразований
	\begin{itemize}
		\item Пока в программе $p_{1}$ есть выражения вида $ifnil(nil, e_{1}, e_{2})$ выполняем преобразование \(T_{7}\)
		\item Пока в программе $p_{1}$ есть выражения вида $ifnil(cons(e_{h}, e_{t}), e_{1}, e_{2})$ выполняем преобразование $T_{8}$
		\item Пока в программе $p_{1}$ есть выражения вида $ifnil(ifnil(e_{1}, e_{2}, e_{3}), e'_{1}, e'_{2})$ выполняем преобразование $T_{9}$
	\end{itemize}
	Результатом работы алгоритма будет программа $p_{2} \in E^{nf}, p_{2} = nf(p)$
\end{enumerate}

\subsection{Оценка увеличения сложности программы при переходе к нормальной форме}
Как можно заметить из оценки сложности алгоритма, проверки эквивалентности двух программ, авторы не оценивают сложность поиска нормального параметра программы.\\ 
Самый очевидный способ нахождения нормального параметра программы - привести обе программы к нормальной форме и посмотреть на них. В связи с этим оценим то, во сколько раз увеличится размер программы при переходе к нормальной форме, согласно алгоритму из раздела 4.1.\\
\begin{thm} В худшем случае нормальная форма nf(p) произвольной программы p имеет размер $\Omega(2^{|p|})$.\end{thm}\\
\emph{Доказательство} Покажем это \\
Рассмотрим такую последовательность программ $p_{1}, p_{2}, \dots, p_{n}, \dots$:\\
$p_{1}: ifnil(ifnil(tl, tl, hd), tl, hd)$\\
$p_{n}: ifnil(ifnil(tl, tl, hd), tl, p_{n-1}), \forall n \ge 2$\\
Заметим, что $|p_{1}| = 7$ и $|p_{n}| = |p_{n-1}| + 6$, $n \ge 2$, а значит, $|p_{n}| = 1 + 6 * n$, $n \ge 1$\\
Пусть \(p_{i}^{nf}\) - нормальная форма программы $p_{i}$, $i \ge 1$. Тогда верно следующее:\\
$p^{nf}_{1} = ifnil(tl, ifnil(tl, tl, hd), ifnil(hd, tl, hd))$\\
$p^{nf}_{n} = ifnil(tl, ifnil(tl, tl, p^{nf}_{n-1}), ifnil(hd, tl, p^{nf}_{n-1}))$\\
При этом $|p^{nf}_1| = 10$ и $|p^{nf}_{n}| = 8 + 2 * |p^{nf}_{n-1}|$ для $n \ge 2$, а значит, $|p^{nf}_n| = 8 + 2 * 8 + 2 * 2 * 8 + ... + 2^{n-1} * 8 + 2^{n} = 9 * 2^{n} - 8$ для $n \ge 1$.\\
Таким образом, $\frac{|p^{nf}_{n}|}{|p_{n}|} = \frac{9 * 2^{n} - 8}{1 + 6 * n}$, а значит, сложность программы при переходе к нормальной форме имеет порядок $\Omega(2^{k})$, где k - сложность изначальной программы. Теорема доказана.

\subsection{Алгоритм поиска миимального размера программы в нормальной форме}
Для поиска нормального параметра программы не обязательно приводить программы к нормальной форме, ведь, как можно заметить, нормальный параметр программы зависит лишь от того, сколько hd и tl может быть в одной композиции в нормальной форме программы. В связи с этим можно попробовать оценить это число, исходя из вида исходной программы.\\
\begin{defn} Длина композиции $\emph{len\_comp}: E^{nf} \rightarrow \mathbb{N}$ определяется следующим образом:
$\emph{len\_comp}(sel_{1} \circ \dots \circ sel_{n}) = n$.\end{defn}\\
\begin{defn} Максимальная глубина программы e - максимальная длина композиции по всем возможным композициям sel в программе e.\end{defn}\\
\begin{lem} В любом из тождеств $T_{1}-T_{3}$ и $T_{7}-T_{9}$, преобразующих программму е к нормальной форме, на каждом шаге их применнеия к программе е максимальная глубина программы е не может увеличиться.\end{lem}\\
\emph{Доказательство} Вытекает из вида тождеств $T_{1}-T_{3}$ и $T_{7}-T_{9}$.\\
\begin{lem} В любом из тождеств $T_{4}-T_{6}$, преобразующих программу p к нормальной форме, на каждом шаге максимальная глубина программы p не может стать больше чем сумма максимальных глубин в подпрограммах с обоих сторон от композиции. То есть, если в программе p есть подпрограммы вида левой части тождества $T_{4}$, то максимальная глубина не может стать больше, чем cумма максимальных глубин подпрограмм $e_{3}$ и максимальной глубины подпрограмм $e_{2}$, $e_{1}$, если в программе p есть подпрограммы вида левой части тождества $T_{5}$, то максимальная глубина не может стать больше, чем cумма максимальных глубин подпрограмм e и максимальной глубины подпрограмм $e_{3}$, $e_{2}$, $e_{1}$, если в программе p есть подпрограммы вида левой части тождества $T_{6}$, то максимальная глубина не может стать больше, чем cумма максимальных глубин подпрограмм e и максимальной глубины подпрограмм $e_{3}$, $e_{2}$, $e_{1}$.\end{lem}\\
\emph{Доказательство} Вытекает из вида тождеств $T_{4}-T_{6}$.\\
\begin{thm} Нормальный параметр программы е не может быть больше количества композиций изначальной программы е + 1.\end{thm}\\
\emph{Доказательство} Следует из Леммы 4.1 и Леммы 4.2. Теорема доказана.\\
Опишем алгоритм вычисления верхней оценки нормального параметра программы.\\
\textbf{Алгоритм} $A1: A1(e) = n$, $e \in E$ - исходная программа, не обязательно в нормальной форме, $n \in \mathbb{N}$ - оценка сверху нормального параметра программы.\\
A1:\\
\begin{enumerate}
\item Завести счетчик $count\_comp$ числа $\circ$ в программе, проставить в него изначальное значение 0.
\item Пройти по всем операциям $op_{i}$ программы, если $op_{i} = \circ$, увеличиваем счетчик $count\_comp$ на единицу.
\item Вернуть $count\_comp + 1$ как результат работы алгоритма.
\end{enumerate}
\begin{thm} Сложность алгоритма А1(e) составляет $O(n)$, где $n = |e|$.\end{thm}\\
\emph{Доказательство} Алгоритм А1 заключается в просмотре всех операций программы e, соответственно и сложность его будет $O(n)$, где $n = |e|$. Теорема доказана.\\
\pagebreak

\section{Полученные результаты}
\begin{enumerate}
\item Описан алгоритм преобразования программы к нормальной форме.
\item Показана неэффективность описанного алгоритма, и для этого оценена снизу экспонентой сложность нормальной формы относительно сложности исходной программы.
\item Предложен алгоритм вычисления нормального параметра программы, показана эффективность этого алгоритма линейной оценкой сверху.
\item Получена оценка сверху нормального параметра программы.
\pagebreak

\addcontentsline{toc}{section}{Список литературы}%
  \begin{thebibliography}{99}%
    \bibitem{jour} \hypertarget{bibl1}{Budd~T.\,A., Angluin~D.. Two notions of correctness and their relation to testing.~// Acta Informatica.~--- 1982.}
    \bibitem{conf} \hypertarget{bibl2}{Krustev~D. Simple Programs on Binary Trees - Testing and Decidable Equivalence.~// Fifth International Valentin Turchin Workshop on Metacomputation.~--- 2016.}
    \bibitem{conf} \hypertarget{bibl3}{Krustev~D. A simple supercompiler formally verified in Coq.~// Proceedings of the Second International Workshop on Metacomputation in Russia.~--- 2010.}
  \end{thebibliography}

\end{document}
